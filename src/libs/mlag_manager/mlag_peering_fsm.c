/* Copyright (c) 2014  Mellanox Technologies, Ltd. All rights reserved.
 *
 * This software is available to you under BSD license below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <utils/mlag_log.h>
#include <utils/mlag_bail.h>
#include <utils/mlag_events.h>
#include <libs/mlag_master_election/mlag_master_election.h>
#include <libs/mlag_common/mlag_common.h>
#include "lib_commu.h"
#include <libs/mlag_common/mlag_comm_layer_wrapper.h>
#include <libs/mlag_manager/mlag_manager_db.h>
#include <libs/mlag_manager/mlag_dispatcher.h>
#include "mlag_peering_fsm.h"
/************************************************
 *  Local Defines
 ***********************************************/
static int
is_all_sync_arrived(mlag_peering_fsm *fsm, int sync_type);


#undef  __MODULE__
#define __MODULE__ MLAG_MANAGER


static mlag_verbosity_t LOG_VAR_NAME(__MODULE__) = MLAG_VERBOSITY_LEVEL_NOTICE;

/************************************************
 *  Local Macros
 ***********************************************/
#define UP 1
#define DOWN 0
/************************************************
 *  Local Type definitions
 ***********************************************/

/************************************************
 *  Global variables
 ***********************************************/


/************************************************
 *  Local variables
 ***********************************************/

/************************************************
 *  Local function declarations
 ***********************************************/

/************************************************
 *  Function implementations
 ***********************************************/

#ifdef FSM_COMPILED
#include \


stateMachine
{
mlag_peering_fsm ()

events {
    peer_up_ev       ()
    peer_conn_ev     ()
    peer_down_ev     ()
    sync_arrived_ev  (int sync_type)

}


state configured {
default
 transitions {
          { peer_up_ev     , $ fsm->conn_state == UP $    , peering  ,  on_peer_up() }
          { peer_up_ev     , $ else $                     , IN_STATE ,  on_peer_up() }
          { peer_conn_ev   , $ fsm->peer_state == UP $    , peering  ,  on_peer_conn() }
          { peer_conn_ev   , $ else $                     , IN_STATE ,  on_peer_conn() }
          { peer_down_ev   , NULL                         , IN_STATE ,  configure_init()  }
  }
}
// ***********************************

state peering {
 transitions {
 { peer_down_ev     , NULL                                                  , configured    , configure_init()  }
 { peer_conn_ev   , NULL                                                    , IN_STATE      ,  on_peer_reconnect() }
 { sync_arrived_ev  , $ is_all_sync_arrived(fsm, ev->sync_type) $           , peer_up       , NULL  }
 { sync_arrived_ev  , $ else $                                              , IN_STATE      , NULL  }

 }
 ef = peering_start
}
// ***********************************
state peer_up {
  transitions {
 { peer_down_ev     , NULL  , configured    , configure_init() }
 { sync_arrived_ev  , NULL  , IN_STATE      , NULL }
 }
ef = peer_up_entry
}

}// end of stateMachine


/* *********************************** */
#endif

/*#$*/
 /* The code  inside placeholders  generated by tool and cannot be modifyed*/


/*----------------------------------------------------------------
            Generated enumerator for  Events of FSM   
---------------------------------------------------------------*/
enum mlag_peering_fsm_events_t{
    peer_up_ev  = 0, 
    peer_conn_ev  = 1, 
    peer_down_ev  = 2, 
    sync_arrived_ev  = 3, 
 };

/*----------------------------------------------------------------
            Generated structures for  Events of FSM   
---------------------------------------------------------------*/
struct  mlag_peering_fsm_peer_up_ev_t
{
    int  opcode;
    const char *name;
};

struct  mlag_peering_fsm_peer_conn_ev_t
{
    int  opcode;
    const char *name;
};

struct  mlag_peering_fsm_peer_down_ev_t
{
    int  opcode;
    const char *name;
};

struct  mlag_peering_fsm_sync_arrived_ev_t
{
    int  opcode;
    const char *name;
    int  sync_type ; 
};

/*----------------------------------------------------------------
           State entry/exit functions prototypes  
---------------------------------------------------------------*/
static int peering_entry_func(mlag_peering_fsm *fsm, struct fsm_event_base *ev);
static int peer_up_entry_func(mlag_peering_fsm *fsm, struct fsm_event_base *ev);
/*----------------------------------------------------------------
            Generated functions for  Events of FSM   
---------------------------------------------------------------*/
int   mlag_peering_fsm_peer_up_ev(struct mlag_peering_fsm  * fsm)
{
     struct mlag_peering_fsm_peer_up_ev_t ev;
     ev.opcode  =  peer_up_ev ;
     ev.name    = "peer_up_ev" ;

     return fsm_handle_event(&fsm->base, (struct fsm_event_base *)&ev);
}
int   mlag_peering_fsm_peer_conn_ev(struct mlag_peering_fsm  * fsm)
{
     struct mlag_peering_fsm_peer_conn_ev_t ev;
     ev.opcode  =  peer_conn_ev ;
     ev.name    = "peer_conn_ev" ;

     return fsm_handle_event(&fsm->base, (struct fsm_event_base *)&ev);
}
int   mlag_peering_fsm_peer_down_ev(struct mlag_peering_fsm  * fsm)
{
     struct mlag_peering_fsm_peer_down_ev_t ev;
     ev.opcode  =  peer_down_ev ;
     ev.name    = "peer_down_ev" ;

     return fsm_handle_event(&fsm->base, (struct fsm_event_base *)&ev);
}
int   mlag_peering_fsm_sync_arrived_ev(struct mlag_peering_fsm  * fsm,  int  sync_type)
{
     struct mlag_peering_fsm_sync_arrived_ev_t ev;
     ev.opcode  =  sync_arrived_ev ;
     ev.name    = "sync_arrived_ev" ;
     ev.sync_type = sync_type ;

     return fsm_handle_event(&fsm->base, (struct fsm_event_base *)&ev);
}
/*----------------------------------------------------------------
                 Reactions of FSM    
---------------------------------------------------------------*/
static  int on_peer_up (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event);
static  int on_peer_conn (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event);
static  int configure_init (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event);
static  int on_peer_reconnect (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event);


/*----------------------------------------------------------------
           State Dispatcher function  
---------------------------------------------------------------*/
static int mlag_peering_fsm_state_dispatcher( mlag_peering_fsm  * fsm, uint16 state, struct fsm_event_base *evt, struct fsm_state_base** target_state );
/*----------------------------------------------------------------
           Initialized  State classes of FSM  
---------------------------------------------------------------*/
 struct fsm_state_base            state_mlag_peering_fsm_configured; 
 struct fsm_state_base            state_mlag_peering_fsm_peering; 
 struct fsm_state_base            state_mlag_peering_fsm_peer_up; 


 struct fsm_state_base      state_mlag_peering_fsm_configured ={ "configured", mlag_peering_fsm_configured , SIMPLE, NULL, NULL, &mlag_peering_fsm_state_dispatcher, NULL, NULL };

 struct fsm_state_base      state_mlag_peering_fsm_peering ={ "peering", mlag_peering_fsm_peering , SIMPLE, NULL, NULL, &mlag_peering_fsm_state_dispatcher, peering_entry_func , NULL };

 struct fsm_state_base      state_mlag_peering_fsm_peer_up ={ "peer_up", mlag_peering_fsm_peer_up , SIMPLE, NULL, NULL, &mlag_peering_fsm_state_dispatcher, peer_up_entry_func , NULL };

static struct fsm_static_data static_data= {0,0,0,0,0 ,{ &state_mlag_peering_fsm_configured,  &state_mlag_peering_fsm_peering,  &state_mlag_peering_fsm_peer_up, }
};

 static struct fsm_state_base * default_state = &state_mlag_peering_fsm_configured ;
/*----------------------------------------------------------------
           StateDispatcher of FSM  
---------------------------------------------------------------*/

static int mlag_peering_fsm_state_dispatcher( mlag_peering_fsm  * fsm, uint16 state, struct fsm_event_base *evt, struct fsm_state_base** target_state )
{
  int err=0;
  struct fsm_timer_event *event = (  struct fsm_timer_event * )evt;
  switch(state) 
  {

   case mlag_peering_fsm_configured : 
    {
      if ( event->opcode == peer_up_ev )
      {
         SET_EVENT(mlag_peering_fsm , peer_up_ev)
         if(  fsm->conn_state == UP  )
         {/*tr00:*/
            err = on_peer_up( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 101*/ 
            *target_state =  &state_mlag_peering_fsm_peering;
            return err;
         }
         else
         {/*tr01:*/
           fsm->base.reaction_in_state = 1;
           err = on_peer_up( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 102*/ 
            *target_state =  &state_mlag_peering_fsm_configured;
            return err;
         }
      }

      else if ( event->opcode == peer_conn_ev )
      {
         SET_EVENT(mlag_peering_fsm , peer_conn_ev)
         if(  fsm->peer_state == UP  )
         {/*tr02:*/
            err = on_peer_conn( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 103*/ 
            *target_state =  &state_mlag_peering_fsm_peering;
            return err;
         }
         else
         {/*tr03:*/
           fsm->base.reaction_in_state = 1;
           err = on_peer_conn( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 104*/ 
            *target_state =  &state_mlag_peering_fsm_configured;
            return err;
         }
      }

      else if ( event->opcode == peer_down_ev )
      {
         SET_EVENT(mlag_peering_fsm , peer_down_ev)
         {/*tr04:*/
           fsm->base.reaction_in_state = 1;
           err = configure_init( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 105*/ 
            *target_state =  &state_mlag_peering_fsm_configured;
            return err;
         }
      }

    }break;

   case mlag_peering_fsm_peering : 
    {
      if ( event->opcode == peer_down_ev )
      {
         SET_EVENT(mlag_peering_fsm , peer_down_ev)
         {/*tr10:*/
            err = configure_init( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 112*/ 
            *target_state =  &state_mlag_peering_fsm_configured;
            return err;
         }
      }

      else if ( event->opcode == peer_conn_ev )
      {
         SET_EVENT(mlag_peering_fsm , peer_conn_ev)
         {/*tr11:*/
           fsm->base.reaction_in_state = 1;
           err = on_peer_reconnect( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 113*/ 
            *target_state =  &state_mlag_peering_fsm_peering;
            return err;
         }
      }

      else if ( event->opcode == sync_arrived_ev )
      {
         SET_EVENT(mlag_peering_fsm , sync_arrived_ev)
         if(  is_all_sync_arrived(fsm, ev->sync_type)  )
         {/*tr12:*/
              /* Source line = 114*/ 
            *target_state =  &state_mlag_peering_fsm_peer_up;
            return err;
         }
         else
         {/*tr13:*/
           fsm->base.reaction_in_state = 1;
             /* Source line = 115*/ 
            *target_state =  &state_mlag_peering_fsm_peering;
            return err;
         }
      }

    }break;

   case mlag_peering_fsm_peer_up : 
    {
      if ( event->opcode == peer_down_ev )
      {
         SET_EVENT(mlag_peering_fsm , peer_down_ev)
         {/*tr20:*/
            err = configure_init( fsm, DEFAULT_PARAMS_D, evt);  /* Source line = 123*/ 
            *target_state =  &state_mlag_peering_fsm_configured;
            return err;
         }
      }

      else if ( event->opcode == sync_arrived_ev )
      {
         SET_EVENT(mlag_peering_fsm , sync_arrived_ev)
         {/*tr21:*/
           fsm->base.reaction_in_state = 1;
             /* Source line = 124*/ 
            *target_state =  &state_mlag_peering_fsm_peer_up;
            return err;
         }
      }

    }break;

   default:
   break;

  }
  return FSM_NOT_CONSUMED;

}
/*----------------------------------------------------------------
              Constructor of FSM   
---------------------------------------------------------------*/
int mlag_peering_fsm_init(struct mlag_peering_fsm *fsm, fsm_user_trace user_trace, void * sched_func, void * unsched_func)
 {

       fsm_init(&fsm->base,  default_state, 3, NULL, user_trace, sched_func, unsched_func, &static_data);

      return 0;
 }
 /*  per state functions*/
/*----------------------------------------------------------------
              Getters for each State   
---------------------------------------------------------------*/
tbool mlag_peering_fsm_configured_in(struct mlag_peering_fsm *fsm){
    return fsm_is_in_state(&fsm->base, mlag_peering_fsm_configured);
}
tbool mlag_peering_fsm_peering_in(struct mlag_peering_fsm *fsm){
    return fsm_is_in_state(&fsm->base, mlag_peering_fsm_peering);
}
tbool mlag_peering_fsm_peer_up_in(struct mlag_peering_fsm *fsm){
    return fsm_is_in_state(&fsm->base, mlag_peering_fsm_peer_up);
}
/*----------------------------------------------------------------
                 Reactions of FSM  (within comments . user may paste function body outside placeholder region)  
---------------------------------------------------------------*/

/*static  int on_peer_up (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event)
 {
   SET_EVENT(mlag_peering_fsm , peer_up_ev) ; 
 }
static  int on_peer_conn (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event)
 {
   SET_EVENT(mlag_peering_fsm , peer_conn_ev) ; 
 }
static  int configure_init (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event)
 {
   SET_EVENT(mlag_peering_fsm , peer_down_ev) ; 
 }
static  int on_peer_reconnect (mlag_peering_fsm  * fsm, int parameter, struct fsm_event_base *event)
 {
   SET_EVENT(mlag_peering_fsm , peer_conn_ev) ; 
 }


*/
/*   10684*/

/*#$*/

/**
 *  This function sets module log verbosity level
 *
 *  @param verbosity - new log verbosity
 *
 * @return void
 */
void
mlag_peering_fsm_log_verbosity_set(mlag_verbosity_t verbosity)
{
    LOG_VAR_NAME(__MODULE__) = verbosity;
}

/*
 *  This function checks all modules sync was accepted
 *
 * @param[in] fsm - current FSM
 * @param[in] sync_type - last arrived sync type
 *
 * @return 0 if operation completes successfully.
 */
static int
is_all_sync_arrived(mlag_peering_fsm *fsm, int sync_type)
{
    fsm->sync_states |= sync_type;
    if (fsm->igmp_enabled == FALSE) {
        fsm->sync_states |= IGMP_PEER_SYNC;
    }
    if (fsm->lacp_enabled == FALSE) {
        fsm->sync_states |= LACP_PEER_SYNC;
    }
    if ((fsm->sync_states & ALL_PEER_SYNC) == ALL_PEER_SYNC) {
        return TRUE;
    }
    return FALSE;
}

/*
 * This function is called when peer up event arrived
 *
 * @param[in] fsm - fsm pointer
 * @param[in] parameter - new state value
 * @param[in] event - base event pointer
 *
 * @return 0 if operation completes successfully.
 */
static int
on_peer_up(mlag_peering_fsm  * fsm, int parameter,
           struct fsm_event_base *event)
{
    int err = 0;

    UNUSED_PARAM(parameter);
    UNUSED_PARAM(event);

    fsm->peer_state = UP;

    return err;
}

/*
 * This function is called when peer conn event arrived
 *
 * @param[in] fsm - fsm pointer
 * @param[in] parameter - new state value
 * @param[in] event - base event pointer
 *
 * @return 0 if operation completes successfully.
 */
static int
on_peer_conn(mlag_peering_fsm  * fsm, int parameter,
             struct fsm_event_base *event)
{
    int err = 0;

    UNUSED_PARAM(parameter);
    UNUSED_PARAM(event);

    fsm->conn_state = UP;

    return err;
}

/*
 * This function is called when peer is entering peering state
 *
 * @param[in] fsm - fsm pointer
 * @param[in] parameter - new state value
 * @param[in] event - base event pointer
 *
 * @return 0 if operation completes successfully.
 */
static int
configure_init(mlag_peering_fsm  * fsm, int parameter,
               struct fsm_event_base *event)
{
    int err = 0;

    UNUSED_PARAM(parameter);
    UNUSED_PARAM(event);

    fsm->peer_state = DOWN;
    fsm->conn_state = DOWN;
    fsm->sync_states = 0;


    return err;
}

/*
 * This function is called when peer reconnects
 *
 * @param[in] fsm - fsm pointer
 * @param[in] parameter - new state value
 * @param[in] event - base event pointer
 *
 * @return 0 if operation completes successfully.
 */
static int
on_peer_reconnect(mlag_peering_fsm  * fsm, int parameter,
                  struct fsm_event_base *event)
{
    int err = 0;

    UNUSED_PARAM(parameter);
    UNUSED_PARAM(event);

    fsm->conn_state = UP;
    fsm->sync_states = 0;

    /* send message - peer start */
    err = fsm->peer_sync_start_cb(fsm->peer_id);
    MLAG_BAIL_ERROR_MSG(err, "Failed in notify peer [%d] start \n",
                        fsm->peer_id);

bail:
    return err;
}

/*
 *  This function is a reaction to peering state entry.
 *  It triggers peering by sending peer start message
 *
 * @param[in] fsm - current FSM
 * @param[in] ev - event content
 *
 * @return 0 if operation completes successfully.
 */
static int
peering_entry_func(mlag_peering_fsm *fsm, struct fsm_event_base *ev)
{
    int err = 0;

    UNUSED_PARAM(ev);
    fsm->sync_states = 0;

    /* send message - peer start */
    err = fsm->peer_sync_start_cb(fsm->peer_id);
    MLAG_BAIL_ERROR_MSG(err, "Failed in notify peer [%d] start \n",
                        fsm->peer_id);

bail:
    return err;
}

/*
 *  This function is a reaction to peer up state entry.
 *  It triggers peer enable notification
 *
 * @param[in] fsm - current FSM
 * @param[in] ev - event content
 *
 * @return 0 if operation completes successfully.
 */
static int
peer_up_entry_func(mlag_peering_fsm *fsm, struct fsm_event_base *ev)
{
    int err = 0;

    UNUSED_PARAM(ev);

    MLAG_LOG(MLAG_LOG_DEBUG, "Peer Enable Peer [%d] \n", fsm->peer_id);

    /* notify peer sync done */
    fsm->peer_sync_done_cb(fsm->peer_id);

    return err;
}

